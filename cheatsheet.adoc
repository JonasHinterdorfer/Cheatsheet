= Angular & .NET Cheatsheet 
{docdate}
:doctype: book
:encoding: utf-8
:lang: en
:toc: left
:toclevels: 3
:sectanchors: 
:sectnums:
:sectnumlevels: 3
:xrefstyle: short
:source-highlighter: rouge
:rouge-style: github
:icons: font
:stem: latexmath
:experimental:
:pdf-theme: school
:pdf-themesdir: ~/.asciidoctor/themes
:allow-uri-read:
:sectlinks:
:!chapter-signifier:
:imagesdir: resources

== Frontend

=== Authentication

==== Interceptor

*Beschreibung:*   
Der HTTP-Interceptor ist eine Middleware-Komponente, die automatisch bei *jedem* ausgehenden HTTP-Request ausgeführt wird. Er fügt den JWT-Token aus dem SessionStorage als Bearer-Token in den Authorization-Header ein, sodass authentifizierte API-Anfragen möglich sind.

*Wichtige Hinweise:*
- SessionStorage wird beim Schließen des Browser-Tabs gelöscht - für persistente Anmeldung localStorage verwenden
- Der Interceptor muss in `app.config.ts` unter `provideHttpClient(withInterceptors([authInterceptor]))` registriert werden

[source,typescript]
----
export const authInterceptor: HttpInterceptorFn = (request, next) => {
  const jwt = sessionStorage.getItem('jwt');
  const isLoggedIn = jwt;
  const isApiUrl = request.url.startsWith(environment.apiBaseUrl);
  if (isLoggedIn && isApiUrl) {
    request = request.clone({
      setHeaders: { Authorization: `Bearer ${jwt}` }
    });
  }

  return next(request);
}
----

==== Auth Guard

*Beschreibung:*  
Ein Route Guard, der den Zugriff auf geschützte Routen kontrolliert. Er prüft vor dem Laden einer Route, ob ein gültiger JWT-Token im SessionStorage vorhanden ist. Ist dies nicht der Fall, wird der User automatisch zur Login-Seite umgeleitet.

*Wichtige Hinweise:*
- Muss in den `app.routes.ts` bei den jeweiligen Routen mit `canActivate: [AuthGuard]` aktiviert werden
- Der Guard muss in `app.config.ts` mit `provideRouter(routes)` registriert werden

[source,typescript]
----
import { Router, CanActivate } from '@angular/router';
import {inject, Injectable} from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class AuthGuard implements CanActivate {
  private router = inject(Router);

  canActivate(): boolean {
    const jwt = sessionStorage.getItem('jwt');
    if (!jwt) {
      this.router.navigate(['login']);
      return false;
    }
    return true;
  }
}
----

=== Directives

==== Filter Directives

*Beschreibung:*  
Custom Validators für Template-Driven Forms. Diese Directive validiert Benutzereingaben *synchron* und gibt sofortiges Feedback. Ideal für einfache Validierungen wie Zahlenbereich, Format-Checks oder Pflichtfelder.

*Wichtige Hinweise:*
- Muss im `imports` Array der Komponente registriert werden (Standalone Components)
- Bei NgModule: Im `declarations` Array des Moduls registrieren
- Die Directive muss das `Validator` Interface implementieren
- Rückgabe `null` bedeutet valide, jedes andere Objekt ist ein Fehler
- `ValidationErrors` Objekt kann mehrere Fehler enthalten: `{ invalid: true, outOfRange: true }`
- Prüfe immer auf leere Werte (`!control.value || control.value === ""`) vor der Validierung
- Verwende sprechende Error-Keys: `{ hourOutOfRange: true }` statt `{ invalid: true }`
- Zeige Fehlermeldungen mit `@if(hourInput.errors?.['hourOutOfRange']) {<div>...</div>}`

[source,typescript]
----
@Directive({
  selector: '[appValidateHour]'
})
export class ValidateHour implements Validator {
  validate(control: AbstractControl): ValidationErrors | null {
    if(!control.value || control.value === "") return null;
    const parsed = parseInt(control.value);
    if(isNaN(parsed)) return { notANumber: true};
    if(parsed > 23 || parsed < 0) {
      return { numberOutOfRange: true};
    }
    return null;
  }
}
----

==== Async Directives

*Beschreibung:*  
Async Validators für komplexe Validierungen die eine Backend-Abfrage erfordern, z.B. Prüfung ob Username bereits existiert, ob eine ID gültig ist, oder ob ein Wert in der Datenbank vorhanden ist. Die Validierung läuft asynchron und blockiert das UI nicht.

*Wichtige Hinweise:*
- Muss `AsyncValidator` Interface implementieren (nicht `Validator`!)
- Provider-Konfiguration mit `NG_ASYNC_VALIDATORS` ist zwingend erforderlich
- `multi: true` erlaubt mehrere Async Validators auf einem Input
- Rückgabe muss `Observable<ValidationErrors | null>` sein
- Während der Validierung hat das Control den Status `PENDING`

*Best Practice:*
- Verwende `debounceTime(300)` um Requests zu verzögern bis User fertig getippt hat
- Zeige Loading-Spinner während `control.pending === true`
- Cache API-Responses um unnötige Requests zu vermeiden
- Kombiniere mit synchroner Validierung: erst Format prüfen, dann Backend-Call

[source,typescript]
----
@Directive({
  selector: '[appRomanCheck]',
  providers: [
    {
      provide: NG_ASYNC_VALIDATORS,
      useExisting: RomanCheck,
      multi: true
    }
  ]
})
export class RomanCheck implements AsyncValidator {
  private readonly dataService: DataService = inject(DataService);

  validate(control: AbstractControl): Observable<ValidationErrors | null> {
    const value: string = control.value;

    return from(this.dataService.isValid(value)).pipe(
      map((result: boolean) => (result ? null : { invalid: true }))
    );
  }
}
----

=== Routing

==== Routes

*Beschreibung:*  
Die zentrale Router-Konfiguration definiert alle verfügbaren Routen der Applikation. Jede Route mappt einen URL-Pfad auf eine Component und kann optional Guards, Resolver oder weitere Konfigurationen enthalten.

*Wichtige Hinweise:*
- Reihenfolge der Routes ist wichtig! Die erste passende Route wird verwendet
- `pathMatch: 'full'` bei Redirects verwenden, sonst matched jede URL die mit dem Pfad beginnt
- Optionale Wildcard-Route `{ path: '**', component: NotFoundComponent }` als *letzte* Route, die als Fallback dient

[source,typescript]
----
export const routes: Routes = [
    { path: '', pathMatch: 'full', redirectTo: 'login'},
    { path: 'login', component: LoginComponent },
    { path: 'home', component: HomeComponent, canActivate: [AuthGuard]},
    { path: 'overview', component: InputDeviceOverviewComponent, canActivate: [AuthGuard]}
];
----

==== Navigation

*Beschreibung:*  
Programmatische Navigation ermöglicht das Wechseln zwischen Routes im TypeScript-Code, z.B. nach erfolgreicher Formular-Submission, Login oder bei Button-Clicks. Der Router-Service stellt verschiedene Methoden für Navigation bereit.

*Wichtige Hinweise:*
- `router.navigate(['/path'])` ist relativ zum Root (absoluter Pfad)
- `router.navigate(['./path'], {relativeTo: route})` ist relativ zur aktuellen Route
- Query Params separat mit Options-Object übergeben

[source,typescript]
----
this.router.navigate(["/overview"], {
  queryParams: { searchTerm: this.searchTerm() }
});
----

==== Path Parameter

*Beschreibung:*  
Path Parameter (Route Parameters) sind dynamische Segmente in der URL, z.B. `/details/42` wobei `42` die ID ist. Sie werden in der Route-Konfiguration mit `:paramName` definiert und ermöglichen das Laden von spezifischen Ressourcen.

*Wichtige Hinweise:*
- Parameter sind *immer* strings! Konvertierung zu number erforderlich: `parseInt(id)`

[source,typescript]
----
// In app.routes.ts
export const routes: Routes = [
    { path: 'details/:id', component: InputDeviceDetails, canActivate: [AuthGuard]}
];

// Navigation
this.router.navigate(["/details", deviceId]);

// In Component
const id: string | null = this.activeRoute.snapshot.paramMap.get("id");
const parsed = parseInt(id || "");
----

==== Query Parameter

*Beschreibung:*  
Query Parameter sind optionale Parameter die nach dem `?` in der URL stehen, z.B. `/search?term=angular&page=2`. Sie werden für Filterung, Sortierung, Pagination oder optionale Konfiguration verwendet und überleben Route-Changes.

*Wichtige Hinweise:*
- Query Params sind *immer* strings oder string arrays (`?id=1&id=2`)
- `snapshot.paramMap.get("id")` liefert Path Params, nicht Query Params!
- Für Query Params: `snapshot.queryParamMap.get("searchTerm")` verwenden

[source,typescript]
----
// Navigation
this.router.navigate(["/overview"], {
  queryParams: { searchTerm: this.searchTerm() }
});

// In Component
const id: string | null = this.activeRoute.snapshot.queryParamMap.get("id");
const parsed = parseInt(id || "");
----

=== Forms

==== Reactive Forms

*Beschreibung:*  
Reactive Forms (Model-Driven) sind die empfohlene Methode für komplexe Formulare in Angular. Das Form-Model wird im TypeScript-Code definiert und das Template bindet sich daran. Bietet volle Kontrolle, Testbarkeit und Type-Safety.

*Wichtige Hinweise:*
- `ReactiveFormsModule` muss importiert werden
- `[formGroup]` Directive auf `<form>` Element binden
- Verwende `FormBuilder` Service für sauberere Syntax

[source,typescript]
----
@Component({
  selector: 'app-login',
  template: `
    <form [formGroup]="loginForm" (ngSubmit)="onSubmit()">
      <label for="username">Username:</label>
      <input type="text" id="username" formControlName="username" />
      <label for="password">Password:</label>
      <input type="password" id="password" formControlName="password" />
      <button type="submit" [disabled]="!loginForm.valid">Login</button>
    </form>
  `,
})
export class LoginComponent {
  loginForm: FormGroup;
  
  constructor(private fb: FormBuilder) {
    this.loginForm = this.fb.group({
      username: ['', Validators.required],
      password: ['', Validators.required],
    });
  }
  
  onSubmit() {
    if (this.loginForm.valid) {
      const { username, password } = this.loginForm.value;
      // Handle login logic
    }
  }
}
----

==== Template Driven Forms

*Beschreibung:*  
Template Driven Forms sind einfacher zu implementieren und ähneln AngularJS Formularen. Die Form-Logik liegt hauptsächlich im Template mit Directives. Gut geeignet für einfache Formulare mit wenigen Feldern.

*Wichtige Hinweise:*
- `FormsModule` muss importiert werden
- `[(ngModel)]` bindet an Component-Property (Two-Way Binding)

[source,typescript]
----
@Component({
  selector: 'app-login',
  template: `
    <form (ngSubmit)="onSubmit()" #loginForm="ngForm">
      <label for="username">Username:</label>
      <input
        type="text"
        id="username"
        name="username"
        required
        [(ngModel)]="username"
      />
      <label for="password">Password:</label>
      <input
        type="password"
        id="password"
        name="password"
        required
        [(ngModel)]="password"
      />
      <button type="submit" [disabled]="!loginForm.form.valid">Login</button
    </form>
  `,
})
export class LoginComponent {
  username: string = '';
  password: string = '';
  
  onSubmit() {
    // Handle login logic
  }
}
----

=== Signals

*Beschreibung:*  
Signals sind Angulars neues Reaktivitäts-Primitiv (ab v16). Sie ermöglichen Fine-Grained Reactivity, Change Detection Optimierung und bessere Performance. Ein Signal ist ein Wrapper um einen Wert der automatisch Dependencies trackt.

*Wichtige Hinweise:*
- `signal()` erstellt writable Signal, `computed()` für abgeleitete Werte
- Signals müssen mit `()` aufgerufen werden um den Wert zu lesen: `count()`
- Zum Schreiben: `count.set(5)` oder `count.update(v => v + 1)`

==== Models

*Beschreibung:*  
Two-Way Binding von Signals in Standalone Components. Das `model<T>()` Decorator erstellt ein Signal-Property das automatisch mit dem Template synchronisiert wird. Änderungen im Template aktualisieren das Signal und umgekehrt.

*Wichtige Hinweise:*
- `model<T>(defaultValue)` initialisiert das Signal mit einem Standardwert
- Im Template mit `[(ngModel)]="propertyName"` binden
- Änderungen im Template aktualisieren automatisch das Signal

[source,typescript]
----
// Child Component
@Component({
  selector: 'app-device-form',
  template: `
    <form>
      <label for="name">Device Name:</label>
      <input id="name" type="text" [(ngModel)]="deviceName" />

      <label for="description">Description:</label>
      <input id="description" type="text" [(ngModel)]="deviceDescription" />
    </form>
  `,
})
export class DeviceFormComponent {
  deviceName = model<string>('');
  deviceDescription = model<string>('');
}

// Parent Component
@Component({
  template: `
    <app-device-form
      [(deviceName)]="name"
      [(deviceDescription)]="description"
    />
  `
})
export class ParentComponent {
  name = signal<string>('Initial Device');
  description = signal<string>('Initial Description');
}
----

==== Input

*Beschreibung:*  
Signal-basierte Inputs ersetzen das traditionelle `@Input()` Decorator und bieten Type-Safety, automatische Change Detection und bessere Integration mit dem Signal-System. Parent Components können reaktiv Daten an Child Components übergeben.

*Wichtige Hinweise:*
- `input.required<T>()` wirft Compile-Error wenn Property nicht gesetzt wird
- `input<T>(defaultValue)` für optionale Inputs mit Fallback-Wert
- Signal Inputs sind *readonly* - Child kann Wert nicht direkt ändern

[source,typescript]
----
@Component({
  selector: 'app-device-card',
})
export class DeviceCardComponent {
  device = input.required<InputDevice>();
  isRequired = input<boolean>(false);
  title = input<string>('Default Title');
}

// Parent Component
@Component({
  template: `
    <app-device-card 
      [device]="selectedDevice()"
      [isRequired]="true"
      [title]="'Device Details'"
    />
  `
})
export class ParentComponent {
  selectedDevice = signal<InputDevice>({ id: 1, name: 'Device 1' });
}
----

==== Output

*Beschreibung:*  
Signal-basierte Outputs ersetzen `@Output()` EventEmitter und ermöglichen typsichere Event-Kommunikation von Child zu Parent Component. Events werden mit `output<T>()` definiert und können mit oder ohne Daten emittet werden.

*Wichtige Hinweise:*
- `output<T>()` erstellt einen Event-Emitter, *kein* Signal!
- Events werden mit `.emit(value)` ausgelöst (wie bei EventEmitter)
- Parent muss Event im Template mit `(eventName)="handler($event)"` abonnieren

[source,typescript]
----
@Component({
  selector: 'app-device-form',
  template: `
    <button (click)="handleSave()">Save</button>
    <button (click)="handleCancel()">Cancel</button>
  `
})
export class DeviceFormComponent {
  deviceSaved = output<InputDevice>();
  cancelled = output<void>();

  handleSave() {
    const device: InputDevice = { id: 1, name: 'Device 1' };
    this.deviceSaved.emit(device);
  }

  handleCancel() {
    this.cancelled.emit();
  }
}

// Parent Component
@Component({
  template: `
    <app-device-form 
      (deviceSaved)="onDeviceSaved($event)"
      (cancelled)="onCancelled()"
    />
  `
})
export class ParentComponent {
  onDeviceSaved(device: InputDevice) {
    console.log('Device saved:', device);
  }

  onCancelled() {
    console.log('Form cancelled');
  }
}
----

=== HTTP Client

*Beschreibung:*  
Der HttpClient-Service ist Angulars zentrale API für HTTP-Kommunikation. Er bietet eine Observable-basierte API für REST-Calls, automatische JSON-Parsing, Request/Response-Interceptors und Type-Safety durch Generics.

*Wichtige Hinweise:*
- `HttpClientModule` muss in `app.config.ts` mit `provideHttpClient()` registriert werden
- Observables sind lazy - ohne `.subscribe()` wird kein Request gesendet
- Error Handling mit `.pipe(catchError())` implementieren

[source,typescript]
----
import { Injectable } from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams } from '@angular/common/http';
import { Observable, observeOn } from 'rxjs';
import { Game } from '../models/game.model';

const httpOptions = {
  headers: new HttpHeaders({
    'Content-Type': 'application/json'
  })
}
@Injectable({
  providedIn: 'root'
})
export class DataService {
  private apiUrl = "https://h-aitenbichler.cloud.htl-leonding.ac.at/restserver";

  public readonly header = new HttpHeaders({
    'Content-Type': 'application/json'
  });

  constructor(private http: HttpClient) { }
  
  // Optional - Hilfsmethode für Arrays als Query Parameter
  private toQueryParamArray(content: string[]): string {
    return "?sudoku=" + content.join("&sudoku=");
  }
}
----

==== GET

[source,typescript]
----
getGames(): Observable<Game[]> {
  return this.http.get<Game[]>(`${this.apiUrl}/game`);
}
----

[source,typescript]
----
getGame(id: number): Observable<Game> {
  return this.http.get<Game>(`${this.apiUrl}/game/${id}`);
}
----

==== POST

[source,typescript]
----
postGame(game: Game): Observable<Game> {
  return this.http.post<Game>(`${this.apiUrl}/game`, game);
}
----

==== PUT

[source,typescript]
----
putGame(id: number, game: Game) {
  return this.http.put(`${this.apiUrl}/game/${id}`, game,
    {
      headers: this.header,
      observe: 'response'
    });
}
----

==== PATCH

[source,typescript]
----
patchGame(id: number, partialGame: Partial<Game>) {
  return this.http.patch(`${this.apiUrl}/game/${id}`, partialGame,
    {
      headers: this.header,
      observe: 'response'
    });
}
----

==== DELETE

[source,typescript]
----
deleteGame(id: number) {
  return this.http.delete(`${this.apiUrl}/game/${id}`, {
    headers: this.header,
    observe: 'response'
  });
}
----

=== Template Syntax
==== @for

*Beschreibung:*
Die `@for` Direktive ermöglicht das Iterieren über Arrays oder Collections im Template. Sie ist eine Alternative zu `*ngFor` und bietet eine klarere Syntax für das Durchlaufen von Listen.

*Wichtige Hinweise:*
- Verwende `@for (item of items; track item)` um über ein Array zu iterieren
- `track item` hilft Angular, Elemente effizient zu rendern und zu aktualisieren

[source,html]
----
@for (device of devices; track device) {
  <div>{{ device.name }}</div>
}
----

==== @if

*Beschreibung:*
Die `@if` Direktive ermöglicht bedingtes Rendern von Template-Abschnitten basierend auf einem boolean Ausdruck. Sie ist eine Alternative zu `*ngIf` und bietet eine klarere Syntax für bedingte Logik.

*Wichtige Hinweise:*
- Verwende `@if (condition) { ... }` um einen Block nur bei wahrer Bedingung zu rendern
- Optional kann ein `@else { ... }` Block hinzugefügt werden

[source,html]
----
@if (isLoggedIn) {
  <div>Welcome back, user!</div>
} @else {
  <div>Please log in to continue.</div>
}
----

=== Templates

==== Table

[source,html]
----
<table>
      <thead>
        <tr>
          <th>Device</th>
          <th>Description</th>
          <th>Reservation</th>
          <th></th>
        </tr>
      </thead>
    @for (device of filteredDevices; track device) {
      <tbody>
        <tr class="border-bottom">
          <td>{{ device.name }}</td>
          <td>{{ device.description }}</td>
          <td>{{ formatReservationDates(device.reservations) }}</td>
          <td>
            <button class="btn btn-secondary" (click)="detailInputDevice(device.id)">
              Reserve
          </button>
        </td>
        </tr>
      </tbody>
    }
</table>
----

==== Input Form

*Beschreibung:*  
Vollständiges Beispiel eines Reactive Forms zur Erstellung/Bearbeitung von Entities. Zeigt Form-Validierung, Error-Handling, und Submission an Backend-API. Kann sowohl für Create als auch Update verwendet werden.

*Wichtige Hinweise:*
- Verwende `FormBuilder` für saubere Form-Initialisierung
- `patchValue()` zum Befüllen des Forms bei Edit-Mode
- `markAllAsTouched()` zeigt alle Validation-Errors beim Submit
- Disabled-State des Submit-Buttons verhindert ungültige Submissions

[source,typescript]
----
import { Component, OnInit, inject } from '@angular/core';
import { FormBuilder, FormGroup, Validators, ReactiveFormsModule } from '@angular/forms';
import { Router, ActivatedRoute } from '@angular/router';
import { DeviceService } from '../services/device.service';
import { InputDevice } from '../models/input-device.model';

@Component({
  selector: 'app-device-form',
  standalone: true,
  imports: [ReactiveFormsModule],
  templateUrl: './device-form.component.html'
})
export class DeviceFormComponent implements OnInit {
  private fb = inject(FormBuilder);
  private router = inject(Router);
  private route = inject(ActivatedRoute);
  private deviceService = inject(DeviceService);

  deviceForm!: FormGroup;
  isEditMode = false;
  deviceId?: number;
  errorMessage = '';

  ngOnInit(): void {
    this.initializeForm();
    this.checkEditMode();
  }

  private initializeForm(): void {
    this.deviceForm = this.fb.group({
      name: ['', [Validators.required, Validators.minLength(3)]],
      description: ['', [Validators.required, Validators.maxLength(500)]],
      serialNumber: ['', [Validators.required, Validators.pattern(/^[A-Z0-9-]+$/)]],
      location: ['', Validators.required],
      status: ['available', Validators.required]
    });
  }

  private checkEditMode(): void {
    const id = this.route.snapshot.paramMap.get('id');
    if (id) {
      this.isEditMode = true;
      this.deviceId = parseInt(id);
      this.loadDevice(this.deviceId);
    }
  }

  private loadDevice(id: number): void {
    this.deviceService.getDevice(id).subscribe({
      next: (device) => {
        this.deviceForm.patchValue({
          name: device.name,
          description: device.description,
          serialNumber: device.serialNumber,
          location: device.location,
          status: device.status
        });
      },
      error: (error) => {
        this.errorMessage = 'Failed to load device';
        console.error(error);
      }
    });
  }

  onSubmit(): void {
    if (this.deviceForm.invalid) {
      this.deviceForm.markAllAsTouched();
      return;
    }

    const device: InputDevice = this.deviceForm.value;

    const request$ = this.isEditMode
      ? this.deviceService.putDevice(this.deviceId!, device)
      : this.deviceService.postDevice(device);

    request$.subscribe({
      next: (response) => {
        this.router.navigate(['/devices']);
      },
      error: (error) => {
        this.errorMessage = 'Failed to save device';
        console.error(error);
      }
    });
  }

  onCancel(): void {
    this.router.navigate(['/devices']);
  }

  // Helper methods for template
  hasError(controlName: string, errorType: string): boolean {
    const control = this.deviceForm.get(controlName);
    return !!(control?.hasError(errorType) && (control?.dirty || control?.touched));
  }

  getErrorMessage(controlName: string): string {
    const control = this.deviceForm.get(controlName);
    if (!control || !control.errors) return '';

    if (control.hasError('required')) return `${controlName} is required`;
    if (control.hasError('minlength')) {
      const minLength = control.errors['minlength'].requiredLength;
      return `${controlName} must be at least ${minLength} characters`;
    }
    if (control.hasError('maxlength')) {
      const maxLength = control.errors['maxlength'].requiredLength;
      return `${controlName} must not exceed ${maxLength} characters`;
    }
    if (control.hasError('pattern')) return `${controlName} has invalid format`;

    return 'Invalid input';
  }
}
----

[source,html]
----
<!-- filepath: device-form.component.html -->
<div class="container mt-4">
  <div class="card">
    <div class="card-header">
      <h2>{{ isEditMode ? 'Edit Device' : 'New Device' }}</h2>
    </div>
    <div class="card-body">
      @if (errorMessage) {
        <div class="alert alert-danger">{{ errorMessage }}</div>
      }

      <form [formGroup]="deviceForm" (ngSubmit)="onSubmit()">
        <div class="mb-3">
          <label for="name" class="form-label">Device Name *</label>
          <input
            type="text"
            id="name"
            class="form-control"
            formControlName="name"
            [class.is-invalid]="hasError('name', 'required') || hasError('name', 'minlength')"
          />
          @if (hasError('name', 'required') || hasError('name', 'minlength')) {
            <div class="invalid-feedback">{{ getErrorMessage('name') }}</div>
          }
        </div>

        <div class="mb-3">
          <label for="description" class="form-label">Description *</label>
          <textarea
            id="description"
            class="form-control"
            rows="3"
            formControlName="description"
            [class.is-invalid]="hasError('description', 'required') || hasError('description', 'maxlength')"
          ></textarea>
          @if (hasError('description', 'required') || hasError('description', 'maxlength')) {
            <div class="invalid-feedback">{{ getErrorMessage('description') }}</div>
          }
        </div>

        <div class="mb-3">
          <label for="serialNumber" class="form-label">Serial Number *</label>
          <input
            type="text"
            id="serialNumber"
            class="form-control"
            formControlName="serialNumber"
            placeholder="ABC-123-XYZ"
            [class.is-invalid]="hasError('serialNumber', 'required') || hasError('serialNumber', 'pattern')"
          />
          @if (hasError('serialNumber', 'required') || hasError('serialNumber', 'pattern')) {
            <div class="invalid-feedback">{{ getErrorMessage('serialNumber') }}</div>
          }
        </div>

        <div class="mb-3">
          <label for="location" class="form-label">Location *</label>
          <input
            type="text"
            id="location"
            class="form-control"
            formControlName="location"
            [class.is-invalid]="hasError('location', 'required')"
          />
          @if (hasError('location', 'required')) {
            <div class="invalid-feedback">{{ getErrorMessage('location') }}</div>
          }
        </div>

        <div class="mb-3">
          <label for="status" class="form-label">Status *</label>
          <select
            id="status"
            class="form-select"
            formControlName="status"
            [class.is-invalid]="hasError('status', 'required')"
          >
            <option value="available">Available</option>
            <option value="in-use">In Use</option>
            <option value="maintenance">Maintenance</option>
            <option value="retired">Retired</option>
          </select>
          @if (hasError('status', 'required')) {
            <div class="invalid-feedback">{{ getErrorMessage('status') }}</div>
          }
        </div>

        <!-- Action Buttons -->
        <div class="d-flex gap-2">
          <button
            type="submit"
            class="btn btn-primary"
            [disabled]="deviceForm.invalid"
          >
            {{ isEditMode ? 'Update' : 'Create' }}
          </button>
          <button
            type="button"
            class="btn btn-secondary"
            (click)="onCancel()"
          >
            Cancel
          </button>
        </div>
      </form>
    </div>
  </div>
</div>
----

==== Details View

*Beschreibung:*  
Vollständige Detail-Ansicht die ein einzelnes Objekt über ID vom Backend lädt und anzeigt. Zeigt Loading-State, Error-Handling, und Navigation. Kann erweitert werden mit Edit/Delete Funktionen.

*Wichtige Hinweise:*
- Route-Parameter mit `ActivatedRoute.snapshot.paramMap.get('id')` auslesen
- Loading-State während API-Call anzeigen (`isLoading` Flag)
- Error-Handling für 404 Not Found und andere Fehler
- Navigation zurück zur Übersicht mit `router.navigate()`

[source,typescript]
----
import { Component, OnInit, inject, signal } from '@angular/core';
import { Router, ActivatedRoute, RouterLink } from '@angular/router';
import { CommonModule } from '@angular/common';
import { DeviceService } from '../services/device.service';
import { InputDevice } from '../models/input-device.model';

@Component({
  selector: 'app-device-details',
  standalone: true,
  imports: [CommonModule, RouterLink],
  templateUrl: './device-details.component.html'
})
export class DeviceDetailsComponent implements OnInit {
  private router = inject(Router);
  private route = inject(ActivatedRoute);
  private deviceService = inject(DeviceService);

  device = signal<InputDevice | null>(null);
  isLoading = signal<boolean>(true);
  errorMessage = signal<string>('');

  ngOnInit(): void {
    this.loadDevice();
  }

  private loadDevice(): void {
    const idParam = this.route.snapshot.paramMap.get('id');
    
    if (!idParam) {
      this.errorMessage.set('Invalid device ID');
      this.isLoading.set(false);
      return;
    }

    const deviceId = parseInt(idParam);
    
    if (isNaN(deviceId)) {
      this.errorMessage.set('Invalid device ID format');
      this.isLoading.set(false);
      return;
    }

    this.deviceService.getDevice(deviceId).subscribe({
      next: (device) => {
        this.device.set(device);
        this.isLoading.set(false);
      },
      error: (error) => {
        console.error('Failed to load device:', error);
        if (error.status === 404) {
          this.errorMessage.set('Device not found');
        } else {
          this.errorMessage.set('Failed to load device details');
        }
        this.isLoading.set(false);
      }
    });
  }

  onEdit(): void {
    const id = this.device()?.id;
    if (id) {
      this.router.navigate(['/devices', 'edit', id]);
    }
  }

  onDelete(): void {
    const device = this.device();
    if (!device) return;

    if (confirm(`Are you sure you want to delete ${device.name}?`)) {
      this.deviceService.deleteDevice(device.id).subscribe({
        next: () => {
          this.router.navigate(['/devices']);
        },
        error: (error) => {
          console.error('Failed to delete device:', error);
          this.errorMessage.set('Failed to delete device');
        }
      });
    }
  }

  onBack(): void {
    this.router.navigate(['/devices']);
  }

  getStatusBadgeClass(status: string): string {
    const statusClasses: { [key: string]: string } = {
      'available': 'bg-success',
      'in-use': 'bg-warning',
      'maintenance': 'bg-info',
      'retired': 'bg-secondary'
    };
    return statusClasses[status] || 'bg-secondary';
  }

  formatDate(date: string | Date): string {
    return new Date(date).toLocaleDateString('de-AT', {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit'
    });
  }
}
----

[source,html]
----
<div class="container mt-4">
  @if (isLoading()) {
    <div class="text-center">
      <div class="spinner-border" role="status">
        <span class="visually-hidden">Loading...</span>
      </div>
      <p class="mt-2">Loading device details...</p>
    </div>
  }

  @if (errorMessage()) {
    <div class="alert alert-danger">
      {{ errorMessage() }}
      <button class="btn btn-sm btn-outline-danger ms-3" (click)="onBack()">
        Back to Overview
      </button>
    </div>
  }

  @if (device() && !isLoading() && !errorMessage()) {
    <div class="card">
      <div class="card-header d-flex justify-content-between align-items-center">
        <h2 class="mb-0">Device Details</h2>
        <div class="d-flex gap-2">
          <button class="btn btn-primary" (click)="onEdit()">
            <i class="bi bi-pencil"></i> Edit
          </button>
          <button class="btn btn-danger" (click)="onDelete()">
            <i class="bi bi-trash"></i> Delete
          </button>
          <button class="btn btn-secondary" (click)="onBack()">
            <i class="bi bi-arrow-left"></i> Back
          </button>
        </div>
      </div>

      <div class="card-body">
        <div class="row">
          <div class="col-md-6">
            <dl class="row">
              <dt class="col-sm-4">Name:</dt>
              <dd class="col-sm-8">{{ device()!.name }}</dd>

              <dt class="col-sm-4">Serial Number:</dt>
              <dd class="col-sm-8">
                <code>{{ device()!.serialNumber }}</code>
              </dd>

              <dt class="col-sm-4">Status:</dt>
              <dd class="col-sm-8">
                <span class="badge {{ getStatusBadgeClass(device()!.status) }}">
                  {{ device()!.status }}
                </span>
              </dd>

              <dt class="col-sm-4">Location:</dt>
              <dd class="col-sm-8">{{ device()!.location }}</dd>
            </dl>
          </div>

          <div class="col-md-6">
            <dl class="row">
              <dt class="col-sm-4">Created:</dt>
              <dd class="col-sm-8">{{ formatDate(device()!.createdAt) }}</dd>

              <dt class="col-sm-4">Last Updated:</dt>
              <dd class="col-sm-8">{{ formatDate(device()!.updatedAt) }}</dd>

              <dt class="col-sm-4">ID:</dt>
              <dd class="col-sm-8">
                <code>{{ device()!.id }}</code>
              </dd>
            </dl>
          </div>
        </div>

        <div class="row mt-3">
          <div class="col-12">
            <h5>Description</h5>
            <p class="text-muted">{{ device()!.description }}</p>
          </div>
        </div>

        @if (device()!.reservations && device()!.reservations.length > 0) {
          <div class="row mt-3">
            <div class="col-12">
              <h5>Reservations</h5>
              <ul class="list-group">
                @for (reservation of device()!.reservations; track reservation.id) {
                  <li class="list-group-item">
                    <strong>{{ reservation.userName }}</strong>
                    <br />
                    <small class="text-muted">
                      {{ formatDate(reservation.startDate) }} - 
                      {{ formatDate(reservation.endDate) }}
                    </small>
                  </li>
                }
              </ul>
            </div>
          </div>
        }

        @if (device()!.specifications) {
          <div class="row mt-3">
            <div class="col-12">
              <h5>Specifications</h5>
              <dl class="row">
                @for (spec of device()!.specifications | keyvalue; track spec.key) {
                  <dt class="col-sm-3">{{ spec.key }}:</dt>
                  <dd class="col-sm-9">{{ spec.value }}</dd>
                }
              </dl>
            </div>
          </div>
        }
      </div>

      <div class="card-footer text-muted">
        <small>
          Device ID: {{ device()!.id }} | 
          Last updated: {{ formatDate(device()!.updatedAt) }}
        </small>
      </div>
    </div>
  }
</div>
----

== Backend
=== CDI (Dependency Injection)

*Beschreibung:*  
Dependency Injection Container registriert Services die dann automatisch in Controllers/Endpoints injiziert werden können. Ermöglicht loose coupling, bessere Testbarkeit und zentrale Konfiguration.

*Wichtige Hinweise:*
- Services müssen *vor* `var app = builder.Build()` registriert werden
- `AddTransient`: neue Instanz bei jeder Injection (stateless Services)
- `AddScoped`: eine Instanz pro HTTP-Request (z.B. DbContext)
- `AddSingleton`: eine Instanz für gesamte App-Lifetime (Caching, Configuration)
- Interface-Registration (`<IService, Service>`) erlaubt Mocking in Tests

Füge Service in Backend hinzu:

[source,csharp]
----
builder.Services.AddTransient<IMessageService, MessageService>();
----

[source,csharp]
----
builder.Services.AddTransient<MessageService>();
----

=== Swagger

==== Swagger Builder

*Beschreibung:*  
Swagger/OpenAPI UI generiert automatisch interaktive API-Dokumentation. Endpoints können direkt getestet werden, Request/Response Schemas werden visualisiert. Essential für Frontend-Entwickler und API-Testing.

*Wichtige Hinweise:*
- `AddEndpointsApiExplorer()` muss *vor* `AddSwaggerGen()` stehen

[source,csharp]
----
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

builder.Services.AddSingleton<IRomanNumerals, RomanNumerals>();

// Add cors here if needed
builder.Services.AddCors(options =>
{
    options.AddPolicy("AllowAngular",
        policy => policy
            .WithOrigins("http://localhost:4200")
            .AllowAnyHeader()
            .AllowAnyMethod());
});

var app = builder.Build();

// Add cors here if needed
app.UseCors("AllowAngular");

app.UseSwagger();
app.UseSwaggerUI();
----

==== Cors

*Beschreibung:*  
CORS (Cross-Origin Resource Sharing) erlaubt Browser Requests von anderen Domains (z.B. Frontend auf localhost:4200 zu API auf localhost:5000). Ohne CORS blockiert Browser die Requests aus Sicherheitsgründen.

*Wichtige Hinweise:*
- CORS-Policy muss *vor* `app.Build()` registriert werden
- `UseCors()` muss *vor* `UseAuthorization()` stehen (Middleware-Reihenfolge!)

[source,csharp]
----
// Reihenfolge siehe oben
builder.Services.AddCors(options =>
{
    options.AddPolicy("AllowAngular",
        policy => policy
            .WithOrigins("http://localhost:4200")
            .AllowAnyHeader()
            .AllowAnyMethod());
});

app.UseCors("AllowAngular");
----

=== Minimal API

==== GET

[source,csharp]
----
app.MapGet("/isValid", (string literal, IRomanNumerals service) =>
{
    try
    {
        service.ConvertFromRomanLiteral(literal);
        return true;
    }
    catch (Exception ex) when (ex is ArgumentOutOfRangeException or ArgumentException)
    {
        return false;
    }
});
----

==== POST

[source,csharp]
----
app.MapPost("/devices", (InputDevice device, IDeviceService service) =>
{
    try
    {
        var created = service.CreateDevice(device);
        return Results.Created($"/devices/{created.Id}", created);
    }
    catch (Exception ex)
    {
        return Results.BadRequest(ex.Message);
    }
});
----

==== PUT

[source,csharp]
----
app.MapPut("/devices/{id}", (int id, InputDevice device, IDeviceService service) =>
{
    try
    {
        var updated = service.UpdateDevice(id, device);
        return updated != null ? Results.Ok(updated) : Results.NotFound();
    }
    catch (Exception ex)
    {
        return Results.BadRequest(ex.Message);
    }
});
----

==== PATCH

[source,csharp]
----
app.MapPatch("/devices/{id}/status", (int id, string status, IDeviceService service) =>
{
    try
    {
        var updated = service.UpdateDeviceStatus(id, status);
        return updated ? Results.NoContent() : Results.NotFound();
    }
    catch (Exception ex)
    {
        return Results.BadRequest(ex.Message);
    }
});
----

==== DELETE

[source,csharp]
----
app.MapDelete("/devices/{id}", (int id, IDeviceService service) =>
{
    try
    {
        var deleted = service.DeleteDevice(id);
        return deleted ? Results.NoContent() : Results.NotFound();
    }
    catch (Exception ex)
    {
        return Results.BadRequest(ex.Message);
    }
});
----

=== Authentication

*Beschreibung:*  
JWT (JSON Web Token) Authentication für stateless API-Authentifizierung. Token enthält Claims (User-ID, Roles) und wird bei jedem Request im Authorization-Header gesendet.

[source,csharp]
----
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true,
            ValidIssuer = builder.Configuration["Jwt:Issuer"],
            ValidAudience = builder.Configuration["Jwt:Audience"],
            IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(builder.Configuration
["Jwt:Key"]))
        };
    });
----

=== Services

*Beschreibung:*  
Services kapseln Business-Logic und werden via Dependency Injection in Endpoints/Controller injiziert. Ermöglicht Separation of Concerns, bessere Testbarkeit und Code-Reuse.

*Wichtige Hinweise:*
- Services müssen in `Program.cs` registriert werden (siehe 2.1/2.5.3)

==== Service Interface

[source,csharp]
----
namespace YourProject.Services;

public interface IYourService
{
    // Definiere deine Service-Methoden hier
}
----

==== Service Implementation

[source,csharp]
----
namespace YourProject.Services;

public class YourService : IYourService
{
    // Implementiere deine Service-Methoden hier
}
----

==== Service Registration

[source,csharp]
----
builder.Services.AddTransient<IYourService, YourService>();
// oder
builder.Services.AddTransient<YourService>();
----

=== Unit Tests

==== XUnit

*Beschreibung:*
XUnit ist ein populäres Testing-Framework für .NET. Es ermöglicht das Schreiben von Unit-Tests, Integrationstests und End-to-End-Tests. Tests werden in separaten Projekten organisiert und können automatisiert ausgeführt werden.

*Wichtige Hinweise:*
- Test-Projekt muss `xunit` und `xunit.runner.visualstudio` NuGet-Pakete referenzieren
- Test-Klassen müssen mit `[Fact]` oder `[Theory]` dekoriert werden

[source,csharp]
----
using Xunit;
using YourProject.Services;
namespace YourProject.Tests;

public class YourServiceTests
{
    private readonly IYourService _yourService;

    public YourServiceTests()
    {
        _yourService = new YourService();
    }

    [Fact]
    public void YourMethod_ShouldReturnExpectedResult()
    {
        // Arrange
        var input = ...;

        // Act
        var result = _yourService.YourMethod(input);

        // Assert
        Assert.Equal(expectedResult, result);
    }
}
----

==== NUnit

*Beschreibung:*
NUnit ist ein weiteres weit verbreitetes Testing-Framework für .NET. Es bietet ähnliche Funktionalitäten wie XUnit, mit einer etwas anderen Syntax und Struktur. NUnit unterstützt auch Data-Driven Tests und bietet umfangreiche Assertions.

*Wichtige Hinweise:*
- Test-Projekt muss `NUnit` und `NUnit3TestAdapter` NuGet-Pakete referenzieren

[source,csharp]
----
using NUnit.Framework;
using YourProject.Services;
namespace YourProject.Tests;

public class YourServiceTests
{
    private IYourService _yourService;

    [SetUp]
    public void Setup()
    {
        _yourService = new YourService();
    }

    [Test]
    public void YourMethod_ShouldReturnExpectedResult()
    {
        // Arrange
        var input = ...;

        // Act
        var result = _yourService.YourMethod(input);

        // Assert
        Assert.AreEqual(expectedResult, result);
    }
}
----

==== FluentAssertions

*Beschreibung:*
FluentAssertions ist eine Erweiterung für Testing-Frameworks wie XUnit und NUnit, die eine lesbare und ausdrucksstarke Syntax für Assertions bietet. Es verbessert die Klarheit der Tests und erleichtert das Debugging.

*Wichtige Hinweise:*
- Test-Projekt muss `FluentAssertions` NuGet-Paket referenzieren

[source,csharp]
----
using FluentAssertions;
using Xunit;
using YourProject.Services;
namespace YourProject.Tests;

public class YourServiceTests
{
    private readonly IYourService _yourService;

    public YourServiceTests()
    {
        _yourService = new YourService();
    }

    [Fact]
    public void YourMethod_ShouldReturnExpectedResult()
    {
        // Arrange
        var input = ...;

        // Act
        var result = _yourService.YourMethod(input);

        // Assert
        result.Should().Be(expectedResult);
    }
}
----

==== Moq

*Beschreibung:*
Moq ist ein Mocking-Framework für .NET, das es ermöglicht, Abhängigkeiten zu mocken und zu stubben. Ideal für Unit-Tests, um isolierte Testszenarien zu erstellen.

*Wichtige Hinweise:*
- Test-Projekt muss `Moq` NuGet-Paket referenzieren
- Verwende `Mock<T>` um Mocks zu erstellen und Verhalten zu konfigurieren

[source,csharp]
----
using Moq;
using Xunit;
using YourProject.Services;
namespace YourProject.Tests;

public class YourServiceTests
{
    private readonly Mock<IDependencyService> _dependencyServiceMock;
    private readonly IYourService _yourService;

    public YourServiceTests()
    {
        _dependencyServiceMock = new Mock<IDependencyService>();
        _yourService = new YourService(_dependencyServiceMock.Object);
    }

    [Fact]
    public void YourMethod_ShouldReturnExpectedResult()
    {
        // Arrange
        var input = ...;
        _dependencyServiceMock.Setup(ds => ds.SomeMethod(It.IsAny<Type>()))
            .Returns(expectedValue);

        // Act
        var result = _yourService.YourMethod(input);

        // Assert
        Assert.Equal(expectedResult, result);
        _dependencyServiceMock.Verify(ds => ds.SomeMethod(It.IsAny<Type>()), Times.Once);
    }
}
----

==== Testen von Minimal APIs

*Beschreibung:*
Minimal APIs können mit dem `WebApplicationFactory<TEntryPoint>` aus dem `Microsoft.AspNetCore.Mvc.Testing` Paket getestet werden. Dies ermöglicht das Starten der API in einem Test-Host und das Senden von HTTP-Requests.

*Wichtige Hinweise:*
- Test-Projekt muss `Microsoft.AspNetCore.Mvc.Testing` NuGet-Paket referenzieren
- Verwende `HttpClient` um Requests an die API zu senden
[source,csharp]
----
using Microsoft.AspNetCore.Mvc.Testing;
using System.Net.Http;
using System.Threading.Tasks;
using Xunit;
namespace YourProject.Tests;

public class YourApiTests : IClassFixture<WebApplicationFactory<Program>>
{
    private readonly HttpClient _client;

    public YourApiTests(WebApplicationFactory<Program> factory)
    {
        _client = factory.CreateClient();
    }

    [Fact]
    public async Task GetEndpoint_ShouldReturnSuccessStatusCode()
    {
        // Act
        var response = await _client.GetAsync("/your-endpoint");

        // Assert
        response.EnsureSuccessStatusCode();
        var content = await response.Content.ReadAsStringAsync();
        Assert.NotNull(content);
    }
}
----